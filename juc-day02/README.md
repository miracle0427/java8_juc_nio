# 6.实现 Callable 接口 

 Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口

Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。 

Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁。

# 7.Lock 同步锁 

在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。 

ReentrantLock 实现了 Lock 接口，并提供了与 synchronized 相同的互斥性和内存可见性。但相较于 synchronized 提供了更高的处理锁的灵活性。

# 8.Condition 控制线程通信 

Condition接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的Object 版本中的不同。 

在Condition对象中，与 wait、notify 和 notifyAll 方法对应的分别是 await、signal 和 signalAll。 

Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。

# 9.ReadWriteLock 读写锁 

ReadWriteLock 维护了一对相关的锁，一个用于只读操作， 另一个用于写入操作。只要没有 writer，读取锁可以由 多个 reader 线程同时保持。写入锁是独占的。

ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。

# 10.线程八锁 

一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法 

锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的 synchronized方法。加个普通方法后发现和同步锁无关。换成两个对象后，不是同一把锁了，情况立刻变化。 都换成静态同步方法后，情况又变化 。

所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。 

所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！

# 11.线程池 

第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个线程池之 一执行每个提交的任务，通常使用 Executors 工厂方法配置。 

线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 

为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但 是，强烈建议程序员使用较为方便的 Executors 工厂方法 ： Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收） Executors.newFixedThreadPool(int)（固定大小线程池） Executors.newSingleThreadExecutor()（单个后台线程） 它们均为大多数使用场景预定义了设置。

# 12.线程调度 

一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令
